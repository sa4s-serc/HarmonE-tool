<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adaptation Control Plane (ACP) Dashboard</title>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <script src="https://unpkg.com/tailwindcss-jit-cdn@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .tab-active { border-bottom-color: #3b82f6 !important; color: #3b82f6; }
    </style>
</head>
<body class="h-full text-gray-200 font-sans">
    
    <div id="welcome-screen" class="flex items-center justify-center min-h-screen">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl max-w-2xl w-full">
            <h2 class="text-2xl font-bold text-white mb-4">Welcome to the Adaptation Control Plane</h2>
            <p class="text-gray-400 mb-6">Choose an approach to begin. You can run a pre-built demo system (Regression or CV) or define your own custom pipeline.</p>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    
                <div class="p-4 bg-gray-700 rounded-lg">
                    <h3 class="font-semibold text-white text-lg mb-3 border-b border-gray-600 pb-2">Regression (LSTM/SVM/Linear)</h3>
                    <div class="space-y-3">
                        <button id="modal-btn-reg-harmone" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">HarmonE (Score/Drift)</h4>
                            <p class="text-sm text-gray-300">Full logic orchestrated by ACP.</p>
                        </button>
                        <button id="modal-btn-reg-switch" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">Simple R² Switch</h4>
                            <p class="text-sm text-gray-300">Baseline: Switch on R² score drop.</p>
                        </button>
                        <button id="modal-btn-reg-single" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">Single Model (Monitor-Only)</h4>
                            <p class="text-sm text-gray-300">Run one model, monitor only.</p>
                        </button>
                    </div>
                </div>
            
                <div class="p-4 bg-gray-700 rounded-lg">
                    <h3 class="font-semibold text-white text-lg mb-3 border-b border-gray-600 pb-2">Computer Vision (YOLO)</h3>
                    <div class="space-y-3">
                        <button id="modal-btn-cv-harmone" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">HarmonE (Score/Drift)</h4>
                            <p class="text-sm text-gray-300">Full logic orchestrated by ACP.</p>
                        </button>
                        <button id="modal-btn-cv-switch" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">Simple Confidence Switch</h4>
                            <p class="text-sm text-gray-300">Baseline: Switch on confidence drop.</p>
                        </button>
                        <button id="modal-btn-cv-single" class="text-left w-full p-3 bg-gray-600 hover:bg-blue-600 rounded-lg transition-colors">
                            <h4 class="font-semibold text-white">Single Model (Monitor-Only)</h4>
                            <p class="text-sm text-gray-300">Run one model, monitor only.</p>
                        </button>
                    </div>
                </div>
            
                <div class="md:col-span-2">
                    <button id="modal-btn-custom" class="text-left w-full p-4 bg-gray-900 hover:bg-blue-800 rounded-lg transition-colors border border-gray-700">
                        <h3 class="font-semibold text-white">Build Custom System</h3>
                        <p class="text-sm text-gray-400">Go to the Policy Manager to define your own system from scratch.</p>
                    </button>
                </div>
            </div>

        </div>
    </div>
    
    <div id="dashboard-wrapper" class="hidden flex flex-col h-screen">

        <header class="bg-gray-800 shadow-md z-10">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-between items-center h-16">

                <button id="back-to-menu-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-1.5 rounded-md text-sm font-medium transition-colors">
                    &larr; Change Approach
                </button>

                <h1 class="text-2xl font-bold text-white hidden md:block">Adaptation Control Plane (ACP) Dashboard</h1>
                
                <div class="flex items-center space-x-2">
                    <label for="policy-id-input" class="text-sm font-medium">Policy ID:</label>
                    <input type="text" id="policy-id-input" value="harmone_score_policy" class="bg-gray-700 text-white px-3 py-1.5 rounded-md text-sm w-48 md:w-64 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter policy ID to load...">
                    <button id="load-policy-btn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1.5 rounded-md text-sm font-medium transition-colors">Load</button>
                </div>
            </div>
        </header>

        <main class="flex-1 overflow-y-auto bg-gray-900 p-4 lg:p-8">
            <div class="max-w-7xl mx-auto">
                
                <nav class="mb-6 border-b border-gray-700">
                    <ul class="flex space-x-8">
                        <li><button class="tab-btn text-gray-400 hover:text-white py-2 border-b-2 border-transparent transition-colors" data-tab="policy">Policy Management (KR1)</button></li>
                        <li><button class="tab-btn text-gray-400 hover:text-white py-2 border-b-2 border-transparent transition-colors tab-active" data-tab="dashboard">Live Dashboard (KR2)</button></li>
                        <!-- <li><button class="tab-btn text-gray-400 hover:text-white py-2 border-b-2 border-transparent transition-colors" data-tab="history">Adaptation History (KR3)</button></li> -->
                    </ul>
                </nav>

                <div id="message-container" class="hidden text-center p-4 rounded-md mb-4"></div>

                <div class="tab-content" id="dashboard-content">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold text-white">Live Telemetry: <span id="policy-title-dashboard" class="text-blue-400">No Policy Loaded</span></h2>
                        
                        <button id="download-telemetry-btn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-1.5 rounded-md text-sm font-medium transition-colors">
                            Download Telemetry (CSV)
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        
                        <div class="lg:col-span-3 bg-gray-800 p-6 rounded-lg shadow-lg">
                            <h3 id="main-chart-title" class="text-lg font-medium mb-4">Main Metric</h3>
                            <div class="h-80"><canvas id="main-metric-chart"></canvas></div>
                        </div>
                        
                        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                            <h3 id="qa1-chart-title" class="text-lg font-medium mb-4">Associated QA 1</h3>
                            <div class="h-60"><canvas id="qa1-chart"></canvas></div>
                        </div>
                        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                            <h3 id="qa2-chart-title" class="text-lg font-medium mb-4">Associated QA 2</h3>
                            <div class="h-60"><canvas id="qa2-chart"></canvas></div>
                        </div>
                        
                        <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
                            <h3 id="model-chart-title" class="text-lg font-medium mb-4">Model Distribution</h3>
                            <div class="h-60" style="position: relative; max-height: 240px;"><canvas id="model-chart"></canvas></div>
                        </div>
                    </div>
                </div>

                <div class="tab-content hidden" id="policy-content">
                    <h2 class="text-xl font-semibold mb-4 text-white">Policy Management (KR1)</h2>
                    
                    <div class="mb-4">
                        <label for="policy-presets" class="block text-sm font-medium mb-1">Load Preset:</label>
                        <select id="policy-presets" class="w-full bg-gray-700 rounded-md p-2 text-sm">
                            <option value="">-- Select a preset --</option>
                            <optgroup label="Regression Presets">
                                <option value="reg_harmone_score">REG: HarmonE Score Policy</option>
                                <!-- <option value="reg_harmone_drift">REG: HarmonE Drift Policy</option> -->
                                <option value="reg_switch_r2">REG: Simple R² Switch Policy</option>
                            </optgroup>
                            <optgroup label="Computer Vision Presets">
                                <option value="cv_harmone_score">CV: HarmonE Score Policy</option>
                                <!-- <option value="cv_harmone_drift">CV: HarmonE Drift Policy</option> -->
                                <option value="cv_switch_conf">CV: Simple Confidence Switch</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <form id="policy-form" class="bg-gray-800 p-6 rounded-lg shadow-lg space-y-6">
                        
                        <fieldset class="border border-gray-700 p-4 rounded-md">
                            <legend class="text-lg font-medium px-2">General</legend>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
                                <div>
                                    <label for="form-policy-id" class="block text-sm font-medium mb-1">Policy ID</label>
                                    <input type="text" id="form-policy-id" class="w-full bg-gray-700 rounded-md p-2 text-sm" required>
                                </div>
                                <div>
                                    <label for="form-metric" class="block text-sm font-medium mb-1">Metric to Watch (quality_attribute)</label>
                                    <input type="text" id="form-metric" class="w-full bg-gray-700 rounded-md p-2 text-sm" required>
                                </div>
                            </div>
                        </fieldset>

                        <fieldset class="border border-gray-700 p-4 rounded-md">
                            <legend class="text-lg font-medium px-2">Adaptation Boundary</legend>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-2">
                                <div>
                                    <label for="form-condition" class="block text-sm font-medium mb-1">Condition</label>
                                    <select id="form-condition" class="w-full bg-gray-700 rounded-md p-2 text-sm">
                                        <option value="LESS_THAN">LESS_THAN</option>
                                        <option value="GREATER_THAN">GREATER_THAN</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="form-threshold" class="block text-sm font-medium mb-1">Static Threshold</label>
                                    <input type="number" step="0.01" id="form-threshold" class="w-full bg-gray-700 rounded-md p-2 text-sm" required>
                                </div>
                                <div>
                                    <label for="form-dynamic-logic" class="block text-sm font-medium mb-1">Dynamic Logic (Optional)</label>
                                    <input type="text" id="form-dynamic-logic" class="w-full bg-gray-700 rounded-md p-2 text-sm" placeholder="e.g., value > historic_avg * 1.2">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset class="border border-gray-700 p-4 rounded-md">
                            <legend class="text-lg font-medium px-2">Tactics</legend>
                            <div id="tactics-container" class="space-y-4 mt-2">
                                <div class="tactic-group border border-gray-600 p-3 rounded-md space-y-2">
                                    <h4 class="font-medium text-gray-300">Tactic 1</h4>
                                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <div>
                                            <label class="block text-sm font-medium mb-1">Tactic ID</label>
                                            <input type="text" class="tactic-id w-full bg-gray-700 rounded-md p-2 text-sm" required>
                                        </div>
                                        <div>
                                            <label class="block text-sm font-medium mb-1">Priority</label>
                                            <input type="number" value="1" class="tactic-priority w-full bg-gray-700 rounded-md p-2 text-sm" required>
                                        </div>
                                        <div class="md:col-span-2">
                                            <label class="block text-sm font-medium mb-1">Tactic Endpoint URL</label>
                                            <input type="text" class="tactic-endpoint w-full bg-gray-700 rounded-md p-2 text-sm" value="http://localhost:8080/adaptor/tactic" required>
                                        </div>
                                        <div class="flex items-end">
                                            <button type="button" class="remove-tactic-btn bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-md text-sm">Remove</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <button type="button" id="add-tactic-btn" class="mt-4 bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded-md text-sm">+ Add Tactic</button>
                        </fieldset>

                        <fieldset class="border border-gray-700 p-4 rounded-md">
                            <legend class="text-lg font-medium px-2">Associated QAs</legend>
                             <div>
                                <label for="form-qas" class="block text-sm font-medium mb-1">Associated Metrics (comma-separated)</label>
                                <input type="text" id="form-qas" class="w-full bg-gray-700 rounded-md p-2 text-sm" placeholder="e.g., r2_score,normalized_energy,model_used">
                            </div>
                        </fieldset>
                        
                        <div class="flex space-x-4">
                            <button type="submit" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-md text-base font-medium transition-colors">
                                Create / Update (Live)
                            </button>
                            <button type="button" id="download-policy-btn" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-md text-base font-medium transition-colors">
                                Generate & Download File
                            </button>
                        </div>
                    </form>
                </div>

                <div class="tab-content hidden" id="history-content">
                    <h2 class="text-xl font-semibold mb-4 text-white">Adaptation History & Analysis (KR3)</h2>
                    <div id="history-feed" class="space-y-6">
                        <div class="text-gray-400">No adaptation events recorded yet.</div>
                    </div>
                </div>

            </div>
        </main>
    </div>

    <script>
        // === CONFIGURATION ===
        const ACP_SERVER_URL = "http://localhost:5000";
        const POLLING_INTERVAL = 5000;
        const CHART_MAX_DATA_POINTS = 30;

        // === GLOBAL STATE ===
        let currentPolicyId = "";
        let pollingIntervalId = null;
        let chartInstances = {};
        let globalKnowledge = { telemetry_history: [] };

        // === DOM ELEMENTS ===
        const welcomeScreen = document.getElementById('welcome-screen');
        const dashboardWrapper = document.getElementById('dashboard-wrapper');
        const backToMenuBtn = document.getElementById('back-to-menu-btn');

        const loadPolicyBtn = document.getElementById('load-policy-btn');
        const policyIdInput = document.getElementById('policy-id-input');
        const messageContainer = document.getElementById('message-container');
        
        const tabs = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        const policyForm = document.getElementById('policy-form');
        const addTacticBtn = document.getElementById('add-tactic-btn');
        const tacticsContainer = document.getElementById('tactics-container');

        const downloadPolicyBtn = document.getElementById('download-policy-btn');
        const downloadTelemetryBtn = document.getElementById('download-telemetry-btn');
        
        // ▼▼▼ 1. UPDATED PRESETS (WITH ENERGY) ▼▼▼
        const HARMONY_PRESETS = {
            // --- REGRESSION PRESETS ---
            "reg_harmone_score": {
                policy_id: "reg_harmone_score",
                quality_attribute: "score", 
                adaptation_boundary: { condition: "LESS_THAN", threshold: 0.78 },
                tactics: [ { tactic_id: "execute_mape_plan", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["r2_score", "normalized_energy", "model_used", "kl_div"]
            },
            "reg_harmone_drift": {
                policy_id: "reg_harmone_drift",
                quality_attribute: "kl_div", 
                adaptation_boundary: { condition: "GREATER_THAN", threshold: 0.75 },
                tactics: [ { tactic_id: "handle_data_drift", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["kl_div", "model_used"]
            },
            "reg_switch_r2": {
                policy_id: "reg_switch_r2",
                quality_attribute: "r2_score", 
                adaptation_boundary: { condition: "LESS_THAN", threshold: 0.70 },
                tactics: [ { tactic_id: "switch_model_r2_baseline", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["r2_score", "normalized_energy", "model_used"] // <-- ADDED ENERGY
            },
            
            // --- CV PRESETS ---
            "cv_harmone_score": {
                policy_id: "cv_harmone_score",
                quality_attribute: "score", 
                adaptation_boundary: { condition: "LESS_THAN", threshold: 0.78 },
                tactics: [ { tactic_id: "execute_mape_plan", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["confidence", "normalized_energy", "model_used", "kl_div"]
            },
            "cv_harmone_drift": {
                policy_id: "cv_harmone_drift",
                quality_attribute: "kl_div", 
                adaptation_boundary: { condition: "GREATER_THAN", threshold: 0.07 },
                tactics: [ { tactic_id: "handle_data_drift", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["kl_div", "model_used"]
            },
            "cv_switch_conf": {
                policy_id: "cv_switch_confidence",
                quality_attribute: "confidence", 
                adaptation_boundary: { condition: "LESS_THAN", threshold: 0.70 },
                tactics: [ { tactic_id: "switch_model_r2_baseline", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic" } ],
                associated_qas: ["confidence", "normalized_energy", "model_used"] // <-- ADDED ENERGY
            }
        };

        // === HELPER FUNCTION TO SWITCH VIEWS ===
        const showView = (viewName) => {
            if (viewName === 'dashboard') {
                welcomeScreen.classList.add('hidden');
                dashboardWrapper.classList.remove('hidden');
            } else { // 'welcome'
                dashboardWrapper.classList.add('hidden');
                welcomeScreen.classList.remove('hidden');
                
                if (pollingIntervalId) clearInterval(pollingIntervalId);
                pollingIntervalId = null;
                currentPolicyId = "";
                policyIdInput.value = ""; 
                document.getElementById('policy-title-dashboard').textContent = 'No Policy Loaded';
                showMessage("Polling stopped. Select an approach.", "info");
            }
        };

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', () => {

            // ▼▼▼ VIEW NAVIGATION LOGIC (WITH "single" FIX) ▼▼▼
            backToMenuBtn.addEventListener('click', () => {
                showView('welcome');
            });

            // REGRESSION BUTTONS
            document.getElementById('modal-btn-reg-harmone').addEventListener('click', () => {
                populateFormWithPreset(HARMONY_PRESETS.reg_harmone_score);
                policyIdInput.value = HARMONY_PRESETS.reg_harmone_score.policy_id;
                // Auto-select the corresponding preset in dropdown
                document.getElementById('policy-presets').value = 'reg_harmone_score';
                showMessage("Loaded 'REG: HarmonE Demo' preset. Navigate to Live Dashboard (KR2)", "info");
                showView('dashboard');
                document.querySelector('.tab-btn[data-tab="policy"]').click();
            });

            document.getElementById('modal-btn-reg-switch').addEventListener('click', () => {
                populateFormWithPreset(HARMONY_PRESETS.reg_switch_r2);
                policyIdInput.value = HARMONY_PRESETS.reg_switch_r2.policy_id;
                // Auto-select the corresponding preset in dropdown
                document.getElementById('policy-presets').value = 'reg_switch_r2';
                showMessage("Loaded 'REG: Simple R² Switch' preset. Navigate to Live Dashboard (KR2)", "info");
                showView('dashboard');
                document.querySelector('.tab-btn[data-tab="policy"]').click();
            });

            document.getElementById('modal-btn-reg-single').addEventListener('click', () => {
                // Load a minimal preset for single mode with associated QAs for monitoring
                const singlePreset = {
                    policy_id: 'reg_single',
                    quality_attribute: 'r2_score',
                    associated_qas: ['r2_score', 'normalized_energy', 'model_used']
                };
                populateFormWithPreset(singlePreset);
                policyIdInput.value = 'reg_single';
                showMessage("Ready for 'REG: Single Model'. Set 'approach.conf' to 'reg_single'", "info");
                showView('dashboard');
                loadPolicy(); // Automatically load this policy
                document.querySelector('.tab-btn[data-tab="dashboard"]').click();
            });

            // CV BUTTONS
            document.getElementById('modal-btn-cv-harmone').addEventListener('click', () => {
                populateFormWithPreset(HARMONY_PRESETS.cv_harmone_score);
                policyIdInput.value = HARMONY_PRESETS.cv_harmone_score.policy_id;
                // Auto-select the corresponding preset in dropdown
                document.getElementById('policy-presets').value = 'cv_harmone_score';
                showMessage("Loaded 'CV: HarmonE Demo' preset. Navigate to Live Dashboard (KR2)", "info");
                showView('dashboard');
                document.querySelector('.tab-btn[data-tab="policy"]').click();
            });

            document.getElementById('modal-btn-cv-switch').addEventListener('click', () => {
                populateFormWithPreset(HARMONY_PRESETS.cv_switch_conf);
                policyIdInput.value = HARMONY_PRESETS.cv_switch_conf.policy_id;
                // Auto-select the corresponding preset in dropdown
                document.getElementById('policy-presets').value = 'cv_switch_conf';
                showMessage("Loaded 'CV: Simple Confidence Switch' preset. Navigate to Live Dashboard (KR2)", "info");
                showView('dashboard');
                document.querySelector('.tab-btn[data-tab="policy"]').click();
            });

            document.getElementById('modal-btn-cv-single').addEventListener('click', () => {
                // Load a minimal preset for CV single mode with associated QAs for monitoring
                const cvSinglePreset = {
                    policy_id: 'cv_single',
                    quality_attribute: 'confidence',
                    associated_qas: ['confidence', 'normalized_energy', 'model_used']
                };
                populateFormWithPreset(cvSinglePreset);
                policyIdInput.value = 'cv_single';
                showMessage("Ready for 'CV: Single Model'. Set 'approach.conf' to 'cv_single'", "info");
                showView('dashboard');
                loadPolicy(); // Automatically load this policy
                document.querySelector('.tab-btn[data-tab="dashboard"]').click();
            });

            // CUSTOM BUTTON
            document.getElementById('modal-btn-custom').addEventListener('click', () => {
                // Load a basic template for custom policies
                const customTemplate = {
                    policy_id: "my_custom_policy",
                    quality_attribute: "",
                    adaptation_boundary: { condition: "LESS_THAN", threshold: 0.7 },
                    tactics: [{tactic_id: "my_tactic", priority: 1, tactic_endpoint: "http://localhost:8080/adaptor/tactic"}],
                    associated_qas: []
                };
                populateFormWithPreset(customTemplate); 
                policyIdInput.value = "my_custom_policy";
                // Clear dropdown selection for custom
                document.getElementById('policy-presets').value = '';
                showMessage("Ready to build a custom system. Define your policy below.", "info");
                showView('dashboard');
                document.querySelector('.tab-btn[data-tab="policy"]').click();
            });

            // --- End View Navigation Logic ---


            // Tab switching logic
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('tab-active', 'text-blue-500'));
                    tab.classList.add('tab-active', 'text-blue-500');
                    
                    const tabId = tab.getAttribute('data-tab');
                    tabContents.forEach(content => {
                        content.classList.add('hidden');
                        if (content.id === `${tabId}-content`) {
                            content.classList.remove('hidden');
                        }
                    });
                });
            });

            // Preset dropdown listener
            const presetDropdown = document.getElementById('policy-presets');
            presetDropdown.addEventListener('change', (e) => {
                const presetKey = e.target.value;
                if (presetKey && HARMONY_PRESETS[presetKey]) {
                    populateFormWithPreset(HARMONY_PRESETS[presetKey]);
                    showMessage(`Loaded preset '${presetKey}'. Review and click 'Generate File' or 'Update Live'.`, "info");
                }
            });
            
            // Load Policy button
            loadPolicyBtn.addEventListener('click', loadPolicy);

            // Policy Form listeners
            policyForm.addEventListener('submit', handlePolicySubmit);
            addTacticBtn.addEventListener('click', () => addTacticGroup());
            downloadPolicyBtn.addEventListener('click', handlePolicyDownload);
            tacticsContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-tactic-btn')) {
                    if (tacticsContainer.children.length > 1) {
                        e.target.closest('.tactic-group').remove();
                        updateTacticHeaders();
                    }
                }
            });

            downloadTelemetryBtn.addEventListener('click', handleTelemetryDownload);
            initializeCharts();
            document.querySelector('.tab-btn[data-tab="dashboard"]').click();
        });
        
        // === CHARTING (KR2) ===

        // ▼▼▼ 2. UPDATED INITIALIZE CHARTS ▼▼▼
        function initializeCharts() {
            const lineChartConfig = (title) => ({
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            type: 'time',
                            time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                            ticks: { color: '#9ca3af' },
                            grid: { color: '#374151' }
                        },
                        y: { 
                            ticks: { color: '#9ca3af' },
                            grid: { color: '#374151' },
                            beginAtZero: false
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#e5e7eb' } },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    animation: { duration: 0 }
                }
            });
            
            const doughnutChartConfig = (title) => ({
                type: 'doughnut',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            position: 'bottom',
                            labels: { color: '#e5e7eb' }
                        },
                        title: { display: false, text: title }
                    },
                    animation: { duration: 0 }
                }
            });

            chartInstances.main = new Chart(document.getElementById('main-metric-chart'), lineChartConfig("Main Metric"));
            chartInstances.qa1 = new Chart(document.getElementById('qa1-chart'), lineChartConfig("QA 1"));
            chartInstances.qa2 = new Chart(document.getElementById('qa2-chart'), lineChartConfig("QA 2"));
            // Initialize the new chart
            chartInstances.modelChart = new Chart(document.getElementById('model-chart'), doughnutChartConfig("Model Distribution"));
        }

        // ▼▼▼ 3. UPDATED DASHBOARD CHARTS FUNCTION (ALL NEW LOGIC) ▼▼▼
        function updateDashboardCharts(data) {
            const policy = data.policy || {};
            const telemetry = data.telemetry_history || [];
            
            let mainMetric = policy.quality_attribute || "N/A";
            const boundary = policy.adaptation_boundary || {};
            let threshold = boundary.threshold;
            let thresholdData = [];
            const labels = telemetry.map(t => new Date(t.timestamp * 1000));
            
            // --- "Single Mode" Main Chart Fix ---
            const isSingleMode = currentPolicyId.includes('single');
            if (isSingleMode && policy.associated_qas && policy.associated_qas.length > 0) {
                // For 'single' mode, use the first QA as the "Main Metric"
                mainMetric = policy.associated_qas[0];
                document.getElementById('main-chart-title').textContent = `Main Metric: ${mainMetric} (Monitor-Only)`;
                // No threshold line for single mode
            } else {
                // For all other modes, show the policy's metric and threshold
                document.getElementById('main-chart-title').textContent = `Main Metric: ${mainMetric} (Target: ${boundary.condition || ''} ${threshold || ''})`;
                thresholdData = labels.map(() => threshold); // Only create threshold data if not single mode
            }
            
            const mainMetricData = telemetry.map(t => t[mainMetric]);
            
            updateChart(chartInstances.main, labels, [
                {
                    label: mainMetric,
                    data: mainMetricData,
                    borderColor: '#3b82f6',
                    backgroundColor: '#3b82f6',
                    tension: 0.1,
                    pointRadius: 2
                },
                {
                    label: 'Threshold',
                    data: thresholdData, // This will be empty for single mode, hiding the line
                    borderColor: '#ef4444',
                    backgroundColor: '#ef4444',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                }
            ]);

            // --- Pie Chart & QA Line Chart Logic ---
            const qaNames = policy.associated_qas ? [...policy.associated_qas] : [];
            
            // Check for 'model_used' and render the pie chart
            const modelChartIndex = qaNames.indexOf('model_used');
            if (modelChartIndex > -1) {
                // Remove 'model_used' from qaNames so it doesn't also become a line chart
                qaNames.splice(modelChartIndex, 1); 
                
                // Process data for the pie chart
                const modelCounts = {};
                telemetry.slice(-CHART_MAX_DATA_POINTS).forEach(t => { // Use rolling window for counts
                    const model = t['model_used'];
                    if (model) {
                        modelCounts[model] = (modelCounts[model] || 0) + 1;
                    }
                });
                const modelLabels = Object.keys(modelCounts);
                const modelData = Object.values(modelCounts);

                document.getElementById('model-chart-title').textContent = "Model Distribution";
                updateChart(chartInstances.modelChart, modelLabels, [{
                    label: 'Model Usage',
                    data: modelData,
                    backgroundColor: ['#3b82f6', '#10b981', '#eab308', '#a855f7', '#f472b6', '#6b7280'],
                }]);
            } else {
                // No model_used data, so clear the chart
                document.getElementById('model-chart-title').textContent = "Model Distribution";
                updateChart(chartInstances.modelChart, [], []);
            }
            
            // --- Associated QA Line Charts ---
            // These are now just the first 2 QAs *other* than 'model_used'
            const qaCharts = [chartInstances.qa1, chartInstances.qa2];
            const qaTitles = ['qa1-chart-title', 'qa2-chart-title'];
            const qaColors = ['#10b981', '#eab308'];

            qaNames.forEach((qaName, index) => {
                if (index < qaCharts.length) { // Only fill the 2 available line charts
                    const qaChart = qaCharts[index];
                    const qaTitle = qaTitles[index];
                    if (qaChart && qaTitle) {
                        document.getElementById(qaTitle).textContent = qaName || `Associated QA ${index+1}`;
                        const qaData = telemetry.map(t => t[qaName]);
                        updateChart(qaChart, labels, [{
                            label: qaName,
                            data: qaData,
                            borderColor: qaColors[index],
                            backgroundColor: qaColors[index],
                            tension: 0.1
                        }]);
                    }
                }
            });

            // Clear unused line charts
            for (let i = qaNames.length; i < qaCharts.length; i++) {
                const qaChart = qaCharts[i];
                const qaTitle = qaTitles[i];
                if (qaChart && qaTitle) {
                    document.getElementById(qaTitle).textContent = `Associated QA ${i+1}`;
                    updateChart(qaChart, [], []);
                }
            }
        }
        
        // ▼▼▼ 4. UPDATED UPDATECHART FUNCTION (handles pie charts) ▼▼▼
        function updateChart(chart, labels, datasets) {
            // Handle doughnut charts (labels are part of data)
            if (chart.config.type === 'doughnut') {
                chart.data.labels = labels;
                chart.data.datasets = datasets;
            } 
            // Handle line charts (labels are on x-axis)
            else {
                const dataLength = labels.length;
                const sliceStart = Math.max(0, dataLength - CHART_MAX_DATA_POINTS);
                
                chart.data.labels = labels.slice(sliceStart);
                chart.data.datasets = datasets.map(ds => ({
                    ...ds,
                    data: ds.data.slice(sliceStart)
                }));
            }
            chart.update();
        }

        // === API & DATA HANDLING ===

        async function loadPolicy() {
            const policyId = policyIdInput.value;
            if (!policyId) {
                showMessage("Please enter a Policy ID.", "error");
                return;
            }
            
            currentPolicyId = policyId;
            document.getElementById('policy-title-dashboard').textContent = `Policy: ${policyId}`;

            if (pollingIntervalId) {
                clearInterval(pollingIntervalId);
            }

            await fetchKnowledge();
            pollingIntervalId = setInterval(fetchKnowledge, POLLING_INTERVAL);
        }

        async function fetchKnowledge() {
            if (!currentPolicyId) return;

            try {
                const response = await fetch(`${ACP_SERVER_URL}/api/knowledge/${currentPolicyId}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        showMessage(`Policy '${currentPolicyId}' not found on server. You can create it in the Policy Management tab.`, "warning");
                    } else {
                        throw new Error(`Server error: ${response.statusText}`);
                    }
                    const data = { policy: { policy_id: currentPolicyId }, telemetry_history: [], intervention_logs: [] };
                    globalKnowledge = data;
                    updateDashboardCharts(data);
                    updatePolicyForm(data);
                    updateHistoryFeed(data);
                    return;
                }
                
                const data = await response.json();
                globalKnowledge = data;
                
                updateDashboardCharts(data);
                updatePolicyForm(data);
                updateHistoryFeed(data);

                if (data.policy) {
                    showMessage(`Successfully loaded policy '${currentPolicyId}'. Last updated: ${new Date().toLocaleTimeString()}`, "success");
                }

            } catch (error) {
                console.error("Failed to fetch knowledge:", error);
                showMessage(`Failed to connect to ACP server at ${ACP_SERVER_URL}. Is it running?`, "error");
                if (pollingIntervalId) clearInterval(pollingIntervalId);
            }
        }

        function showMessage(text, type = "info") {
            messageContainer.textContent = text;
            messageContainer.classList.remove('hidden', 'bg-red-500', 'bg-green-500', 'bg-yellow-500', 'bg-blue-500');
            
            let bgColor = 'bg-blue-500'; // default info
            if (type === "error") {
                bgColor = 'bg-red-500';
            } else if (type === "success") {
                bgColor = 'bg-green-500';
            } else if (type === "warning") {
                bgColor = 'bg-yellow-500';
            }
            messageContainer.classList.add(bgColor);
            messageContainer.classList.remove('hidden');
        }

        // === POLICY MANAGEMENT (KR1) ===

        function getPolicyFromForm() {
            const policy = {
                policy_id: document.getElementById('form-policy-id').value,
                quality_attribute: document.getElementById('form-metric').value,
                adaptation_boundary: {
                    type: document.getElementById('form-dynamic-logic').value ? "DYNAMIC_THRESHOLD" : "STATIC_THRESHOLD",
                    condition: document.getElementById('form-condition').value,
                    threshold: parseFloat(document.getElementById('form-threshold').value),
                    dynamic_logic: document.getElementById('form-dynamic-logic').value || null
                },
                tactics: [],
                associated_qas: document.getElementById('form-qas').value.split(',').filter(qa => qa.trim() !== "").map(qa => qa.trim())
            };

            document.querySelectorAll('.tactic-group').forEach(group => {
                policy.tactics.push({
                    tactic_id: group.querySelector('.tactic-id').value,
                    priority: parseInt(group.querySelector('.tactic-priority').value),
                    tactic_type: "CORE",
                    tactic_endpoint: group.querySelector('.tactic-endpoint').value
                });
            });
            
            return policy;
        }

        function updatePolicyForm(data) {
            const policy = data.policy || { policy_id: currentPolicyId };
            
            document.getElementById('form-policy-id').value = policy.policy_id || currentPolicyId;
            document.getElementById('form-metric').value = policy.quality_attribute || '';
            document.getElementById('form-qas').value = (policy.associated_qas || []).join(',');

            const boundary = policy.adaptation_boundary || {};
            document.getElementById('form-condition').value = boundary.condition || 'LESS_THAN';
            document.getElementById('form-threshold').value = boundary.threshold || 0;
            document.getElementById('form-dynamic-logic').value = boundary.dynamic_logic || '';

            const tactics = policy.tactics || [];
            tacticsContainer.innerHTML = '';
            
            if (tactics.length === 0) {
                addTacticGroup();
            } else {
                tactics.forEach((tactic, index) => {
                    addTacticGroup(tactic, index + 1);
                });
            }
        }
        
        async function handlePolicySubmit(event) {
            event.preventDefault();
            showMessage("Sending policy to server...", "info");

            try {
                const policy = getPolicyFromForm();
                
                const response = await fetch(`${ACP_SERVER_URL}/api/policy`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(policy)
                });

                if (!response.ok) {
                    throw new Error(`Server responded with status ${response.status}`);
                }

                showMessage("Policy successfully created/updated!", "success");
                
                if (currentPolicyId !== policy.policy_id) {
                    policyIdInput.value = policy.policy_id;
                    loadPolicy();
                }

            } catch (error) {
                console.error("Failed to submit policy:", error);
                showMessage(`Failed to submit policy: ${error.message}`, "error");
            }
        }
        
        function populateFormWithPreset(preset) {
            document.getElementById('form-policy-id').value = preset.policy_id || '';
            document.getElementById('form-metric').value = preset.quality_attribute || '';
            document.getElementById('form-qas').value = (preset.associated_qas || []).join(',');
        
            const boundary = preset.adaptation_boundary || {};
            document.getElementById('form-condition').value = boundary.condition || 'LESS_THAN';
            document.getElementById('form-threshold').value = boundary.threshold || 0;
            document.getElementById('form-dynamic-logic').value = boundary.dynamic_logic || '';
        
            const tactics = preset.tactics || [];
            tacticsContainer.innerHTML = '';

            if (tactics.length === 0) {
                addTacticGroup();
            } else {
                tactics.forEach((tactic, index) => {
                    addTacticGroup(tactic, index + 1);
                });
            }
        }

        function handlePolicyDownload() {
            try {
                const policy = getPolicyFromForm();
                const policyId = policy.policy_id;

                if (!policyId || !policy.quality_attribute) {
                    showMessage("Please fill in at least 'Policy ID' and 'Metric to Watch'.", "error");
                    return;
                }

                const policyString = JSON.stringify(policy, null, 2);
                const blob = new Blob([policyString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${policyId}.json`;
                document.body.appendChild(a);
                a.click();
                
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showMessage(`${policyId}.json downloaded! Move it to your 'policies' folder.`, "success");

            } catch (error) {
                console.error("Failed to generate policy:", error);
                showMessage(`Failed to generate policy: ${error.message}`, "error");
            }
        }

        function handleTelemetryDownload() {
            const telemetry = globalKnowledge.telemetry_history;
            if (!telemetry || telemetry.length === 0) {
                showMessage("No telemetry data to download.", "warning");
                return;
            }
        
            try {
                const allKeys = new Set();
                telemetry.forEach(row => Object.keys(row).forEach(key => allKeys.add(key)));
                const keys = Array.from(allKeys);

                const csvContent = [
                    keys.join(','), // Header row
                    ...telemetry.map(row => 
                        keys.map(key => {
                            let cell = row[key];
                            if (cell === undefined || cell === null) {
                                return "";
                            }
                            if (typeof cell === 'string' && cell.includes(',')) {
                                return `"${cell}"`;
                            }
                            return cell;
                        }).join(',')
                    )
                ].join('\n');
        
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentPolicyId || 'telemetry'}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showMessage("Telemetry CSV downloaded!", "success");
        
            } catch (error) {
                console.error("Failed to generate telemetry CSV:", error);
                showMessage(`Failed to generate CSV: ${error.message}`, "error");
            }
        }


        function addTacticGroup(tactic = null, index = null) {
            const tacticCount = index || tacticsContainer.children.length + 1;
            const newTacticGroup = document.createElement('div');
            newTacticGroup.className = 'tactic-group border border-gray-600 p-3 rounded-md space-y-2';
            newTacticGroup.innerHTML = `
                <h4 class="font-medium text-gray-300">Tactic ${tacticCount}</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-1">Tactic ID</label>
                        <input type="text" class="tactic-id w-full bg-gray-700 rounded-md p-2 text-sm" value="${tactic?.tactic_id || ''}" required>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Priority</label>
                        <input type="number" value="${tactic?.priority || tacticCount}" class="tactic-priority w-full bg-gray-700 rounded-md p-2 text-sm" required>
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-sm font-medium mb-1">Tactic Endpoint URL</label>
                        <input type="text" class="tactic-endpoint w-full bg-gray-700 rounded-md p-2 text-sm" value="${tactic?.tactic_endpoint || 'http://localhost:8080/adaptor/tactic'}" required>
                    </div>
                    <div class="flex items-end">
                        <button type="button" class="remove-tactic-btn bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-md text-sm">Remove</button>
                    </div>
                </div>
            `;
            tacticsContainer.appendChild(newTacticGroup);
        }

        function updateTacticHeaders() {
            document.querySelectorAll('.tactic-group').forEach((group, index) => {
                group.querySelector('h4').textContent = `Tactic ${index + 1}`;
                group.querySelector('.tactic-priority').value = index + 1;
            });
        }


        // === ADAPTATION HISTORY (KR3) ===

        function updateHistoryFeed(data) {
            const feed = document.getElementById('history-feed');
            const interventions = data.intervention_logs || [];
            const telemetry = data.telemetry_history || [];
            const policy = data.policy || {};

            if (interventions.length === 0) {
                feed.innerHTML = '<div class="text-gray-400">No adaptation events recorded yet.</div>';
                return;
            }

            feed.innerHTML = '';
            interventions.slice().reverse().forEach((event, index) => {
                const card = createHistoryCard(event, index, telemetry, policy);
                feed.appendChild(card);
            });
            
            interventions.slice().reverse().forEach((event, index) => {
                renderHistoryChart(event, index, telemetry, policy);
            });
        }
        
        function createHistoryCard(event, index, telemetry, policy) {
            const card = document.createElement('div');
            card.className = 'bg-gray-800 p-6 rounded-lg shadow-lg';
            
            const statusColor = event.status === "CONFIRMED_SUCCESS" ? "text-green-500" : (event.status.includes("FAILED") ? "text-red-500" : "text-yellow-500");
            const boundary = policy.adaptation_boundary || {};
            const mainMetric = policy.quality_attribute;
            const triggerValue = event.trigger_value ? parseFloat(event.trigger_value).toFixed(2) : 'N/A';

            card.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium text-white">Adaptation Event</h3>
                    <span class="text-sm font-mono ${statusColor}">${event.status}</span>
                </div>
                <div class="text-sm text-gray-400 mb-4">${new Date(event.timestamp * 1000).toLocaleString()}</div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div>
                        <div class="text-xs text-gray-500 uppercase">Violation Trigger</div>
                        <div class="text-lg font-semibold text-red-500">${mainMetric || 'N/A'} (${triggerValue})</div>
                        <div class="text-sm text-gray-400">Target: ${boundary.condition || ''} ${boundary.threshold || ''}</div>
                    </div>
                    <div>
                        <div class="text-xs text-gray-500 uppercase">Action Taken</div>
                        <div class="text-lg font-semibold text-blue-400">${event.tactic_id}</div>
                    </div>
                </div>
                
                <div class="mt-4">
                    <h4 class="text-sm font-medium text-gray-300 mb-2">Before & After Performance (${mainMetric || ''})</h4>
                    <div class="h-40 bg-gray-700 p-2 rounded-md">
                        <canvas id="history-chart-${index}"></canvas>
                    </div>
                </div>
            `;
            return card;
        }

        function renderHistoryChart(event, index, telemetry, policy) {
            const canvas = document.getElementById(`history-chart-${index}`);
            if (!canvas) return;

            const mainMetric = policy.quality_attribute;
            const eventTimestamp = event.timestamp;
            
            let eventIndex = telemetry.findIndex(t => t.timestamp >= eventTimestamp);
            if (eventIndex === -1) eventIndex = telemetry.length;

            const dataPointsToShow = 10;
            const startIndex = Math.max(0, eventIndex - dataPointsToShow);
            const endIndex = Math.min(telemetry.length, eventIndex + dataPointsToShow); // <-- Fixed typo 'Mth.min' to 'Math.min'

            const chartData = telemetry.slice(startIndex, endIndex);
            
            const labels = chartData.map(t => new Date(t.timestamp * 1000));
            const data = chartData.map(t => t[mainMetric]);
            
            const eventLine = {
                type: 'line',
                mode: 'vertical',
                scaleID: 'x',
                value: new Date(eventTimestamp * 1000),
                borderColor: '#ef4444',
                borderWidth: 2,
                borderDash: [5, 5],
                label: {
                    content: 'Adaptation Event',
                    enabled: true,
                    position: 'start',
                    backgroundColor: '#ef4444'
                }
            };

            new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: mainMetric,
                        data: data,
                        borderColor: '#3b82f6',
                        tension: 0.1,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { 
                            type: 'time',
                            time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
                            ticks: { color: '#9ca3af', maxTicksLimit: 6 },
                            grid: { color: '#374151' }
                        },
                        y: { 
                            ticks: { color: '#9ca3af', maxTicksLimit: 5 },
                            grid: { color: '#374151' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        annotation: {
                            annotations: {
                                eventLine
                            }
                        }
                    },
                    animation: { duration: 0 }
                }
            });
        }

    </script>
</body>
</html>